// +build ignore

package main

import (
	"bytes"
	"flag"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"go/format"
	"go/scanner"
	"go/token"

	"git.flier.lu/flier/planb/atom"
)

const maxLineLen = 64

var tplTable = template.Must(template.New("atom").Funcs(template.FuncMap{
	"title": strings.Title,
}).Parse(`// DO NOT EDIT IT!
// generated by command: go run genatoms.go {{.Args}}

package {{ .Package }}

import (
    "git.flier.lu/flier/planb/atom"
)

const (
    {{range $atom, $text := .Atoms}}{{title $text}} atom.Atom = 0x{{printf "%08x" $atom.Value}}
    {{end}}
)

const atomData = {{range $i, $line := .Data}}{{if $i}} +
{{end}}{{printf "%q" $line}}{{end}}

var atomCache = atom.Cache {
    {{range $hash, $atom := .Cache}}0x{{printf "%016x" $hash}}: 0x{{printf "%08x" $atom.Value}}, // {{$atom.String}}
    {{end -}}
}
{{if .Test}}
var atomTests = []string{
    {{range $atom, $text := .Atoms}}{{printf "%q" $atom.String}},
    {{end -}}
}
{{end}}
func init() {
    atom.Load([]byte(atomData), atomCache)
}
`))

var (
	flagInputFile       = flag.String("i", "", "read atom from the input file (default STDIN)")
	flagOutputFile      = flag.String("o", "", "write atom table to the output file (default STDOUT)")
	flagPackageName     = flag.String("p", "atom", "generated package name")
	flagTestTable       = flag.Bool("test", false, "generate test table for the atom data")
	flagFormatSource    = flag.Bool("format", true, "format the generated code")
	flagCaseInsensitive = flag.Bool("case-insensitive", true, "case-insensitive atom")
)

func openInput() (*os.File, error) {
	if *flagInputFile == "" {
		return os.Stdin, nil
	}

	return os.Open(*flagInputFile)
}

func openOutput() (*os.File, error) {
	if *flagOutputFile == "" {
		return os.Stdout, nil
	}

	return os.Create(*flagOutputFile)
}

func reportError(pos token.Position, msg string) {
	log.Printf("%s WARN %s", pos, msg)
}

func main() {
	flag.Parse()

	in, err := openInput()

	if err != nil {
		log.Fatalf("fail to open input file, %s", err)
	}

	data, err := ioutil.ReadAll(in)

	if err != nil {
		log.Fatalf("fail to read input file, %s", err)
	}

	fset := token.NewFileSet()
	file := fset.AddFile(*flagInputFile, fset.Base(), len(data))

	var s scanner.Scanner

	s.Init(file, data, reportError, scanner.ScanComments)

	atoms := make(map[atom.Atom]string)

	for {
		_, tok, lit := s.Scan()

		if tok == token.EOF {
			break
		}

		if tok == token.IDENT {
			s := lit

			if *flagCaseInsensitive {
				s = strings.ToLower(s)
			}

			if a := atom.New(s); a != atom.Empty {
				atoms[a] = s
			} else {
				log.Printf("drop a invalid token: %s", s)
			}
		}
	}

	snapshot, cache := atom.Save()

	var lines []string

	for off := 0; off < len(snapshot); off += maxLineLen {
		end := off + maxLineLen

		if end > len(snapshot) {
			end = len(snapshot)
		}

		lines = append(lines, string(snapshot[off:end]))
	}

	args := map[string]interface{}{
		"Args":    strings.Join(os.Args[1:], " "),
		"Package": *flagPackageName,
		"Atoms":   atoms,
		"Data":    lines,
		"Cache":   cache,
		"Test":    *flagTestTable,
	}

	buf := bytes.NewBuffer(nil)

	if err = tplTable.Execute(buf, args); err != nil {
		log.Fatalf("fail to generate atom table, %s", err)
	}

	var src []byte

	if *flagFormatSource {
		src, err = format.Source(buf.Bytes())

		if err != nil {
			log.Fatalf("fail to format generated code, %s", err)
		}
	} else {
		src = buf.Bytes()
	}

	out, err := openOutput()

	if err != nil {
		log.Fatalf("fail to open output file, %s", err)
	}

	if _, err = out.Write(src); err != nil {
		log.Fatalf("fail to write generated code to output file, %s", err)
	}
}
